//
// Copyright 2024 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// Tests for shader interpolation qualifiers
//

#include "test_utils/ANGLETest.h"
#include "test_utils/gl_raii.h"

using namespace angle;

constexpr int kPixelColorThreshhold = 8;

class ShaderOpTest : public ANGLETest<>
{
  protected:
    ShaderOpTest() : ANGLETest()
    {
        setWindowWidth(256);
        setWindowHeight(256);
        setConfigRedBits(8);
        setConfigGreenBits(8);
        setConfigBlueBits(8);
        setConfigAlphaBits(8);
        setConfigDepthBits(24);
        setConfigStencilBits(8);
        setMultisampleEnabled(0);
    }
};

// Simplified test from dEQP-GLES2.functional.fragment_ops.interaction.basic_shader.22
// Test that vulkan drivers correctly handle the constant expression spirv generated by ANGLE
TEST_P(ShaderOpTest, ConstantExpression)
{
    const char *vertSrc = R"(
attribute vec4 pos;

void main()
{
    gl_Position = pos;
}
)";
    // ANGLE and glslang translate below expression in fragment shader differently
    // vec4 c = vec4(1.0, 0.5, 0.5, 0.75)

    // ANGLE:
    // %constVec4 = OpConstantComposite %vec4 %const1 %const2 %const2 %const3
    // %var = OpVariable %PrivateVec4Pointer Private %constVec4
    // %loadedVal = OpLoad %vec4 %var
    // OpStore %gl_fragColor %loadedVal

    // glslang:
    // %constVec4 = OpConstantComposite %vec4 %const1 %const2 %const2 %const3
    // %var = OpVariable %PrivateVec4Pointer Private
    // OpStore %var %constVec4
    // %loadedVal = OpLoad %vec4 %var
    // OpStore %gl_fragColor %loadedVal

    // Both are valid spirv instructions.
    // Tests should pass with spirv generated by ANGLE.

    // Note: setting forceDeferNonConstGlobalInitializers to true will make ANGLE generate the same
    // spirv instruction for the constant expression as glslang.
    const char *fragSrc = R"(
precision mediump float;
vec4 c = vec4(1.0, 0.5, 0.5, 0.75);

void main()
{
    gl_FragColor = c;
}
)";
    ANGLE_GL_PROGRAM(program, vertSrc, fragSrc);
    glUseProgram(program);

    std::array<GLfloat, 16> attribPosData = {1, 1,  0.5, 1, -1, 1,  0.5, 1,
                                             1, -1, 0.5, 1, -1, -1, 0.5, 1};
    GLint attribPosLoc                    = glGetAttribLocation(1, "pos");
    ASSERT(attribPosLoc >= 0);
    glEnableVertexAttribArray(attribPosLoc);
    glVertexAttribPointer(attribPosLoc, 4, GL_FLOAT, GL_FALSE, 0, attribPosData.data());

    const uint16_t indices[] = {0, 1, 2, 2, 1, 3};
    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, &indices[0]);
    EXPECT_PIXEL_COLOR_NEAR(64, 64, GLColor(255, 125, 125, 190), kPixelColorThreshhold);
}

GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(ShaderOpTest);
ANGLE_INSTANTIATE_TEST_ES2(ShaderOpTest);
