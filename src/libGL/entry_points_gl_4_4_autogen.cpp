// GENERATED FILE - DO NOT EDIT.
// Generated by generate_entry_points.py using data from gl.xml.
//
// Copyright 2019 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// entry_points_gl_4_4_autogen.cpp:
//   Defines the GL 4.4 entry points.

#include "libGL/entry_points_gl_4_4_autogen.h"

#include "libANGLE/Context.h"
#include "libANGLE/Context.inl.h"
#include "libANGLE/entry_points_utils.h"
#include "libANGLE/validationEGL.h"
#include "libANGLE/validationES.h"
#include "libANGLE/validationES1.h"
#include "libANGLE/validationES2.h"
#include "libANGLE/validationES3.h"
#include "libANGLE/validationES31.h"
#include "libANGLE/validationESEXT.h"
#include "libANGLE/validationGL44_autogen.h"
#include "libGLESv2/global_state.h"

namespace gl
{
void GL_APIENTRY BindBuffersBase(GLenum target, GLuint first, GLsizei count, const GLuint *buffers)
{
    EVENT(
        "(GLenum target = 0x%X, GLuint first = %u, GLsizei count = %d, const GLuint *buffers = "
        "0x%016" PRIxPTR ")",
        target, first, count, (uintptr_t)buffers);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        bool isCallValid = (context->skipValidation() ||
                            ValidateBindBuffersBase(context, target, first, count, buffers));
        if (isCallValid)
        {
            context->bindBuffersBase(target, first, count, buffers);
        }
        ANGLE_CAPTURE(BindBuffersBase, isCallValid, context, target, first, count, buffers);
    }
}

void GL_APIENTRY BindBuffersRange(GLenum target,
                                  GLuint first,
                                  GLsizei count,
                                  const GLuint *buffers,
                                  const GLintptr *offsets,
                                  const GLsizeiptr *sizes)
{
    EVENT(
        "(GLenum target = 0x%X, GLuint first = %u, GLsizei count = %d, const GLuint *buffers = "
        "0x%016" PRIxPTR ", const GLintptr *offsets = 0x%016" PRIxPTR
        ", const GLsizeiptr *sizes = 0x%016" PRIxPTR ")",
        target, first, count, (uintptr_t)buffers, (uintptr_t)offsets, (uintptr_t)sizes);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        bool isCallValid =
            (context->skipValidation() ||
             ValidateBindBuffersRange(context, target, first, count, buffers, offsets, sizes));
        if (isCallValid)
        {
            context->bindBuffersRange(target, first, count, buffers, offsets, sizes);
        }
        ANGLE_CAPTURE(BindBuffersRange, isCallValid, context, target, first, count, buffers,
                      offsets, sizes);
    }
}

void GL_APIENTRY BindImageTextures(GLuint first, GLsizei count, const GLuint *textures)
{
    EVENT("(GLuint first = %u, GLsizei count = %d, const GLuint *textures = 0x%016" PRIxPTR ")",
          first, count, (uintptr_t)textures);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        bool isCallValid = (context->skipValidation() ||
                            ValidateBindImageTextures(context, first, count, textures));
        if (isCallValid)
        {
            context->bindImageTextures(first, count, textures);
        }
        ANGLE_CAPTURE(BindImageTextures, isCallValid, context, first, count, textures);
    }
}

void GL_APIENTRY BindSamplers(GLuint first, GLsizei count, const GLuint *samplers)
{
    EVENT("(GLuint first = %u, GLsizei count = %d, const GLuint *samplers = 0x%016" PRIxPTR ")",
          first, count, (uintptr_t)samplers);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        bool isCallValid =
            (context->skipValidation() || ValidateBindSamplers(context, first, count, samplers));
        if (isCallValid)
        {
            context->bindSamplers(first, count, samplers);
        }
        ANGLE_CAPTURE(BindSamplers, isCallValid, context, first, count, samplers);
    }
}

void GL_APIENTRY BindTextures(GLuint first, GLsizei count, const GLuint *textures)
{
    EVENT("(GLuint first = %u, GLsizei count = %d, const GLuint *textures = 0x%016" PRIxPTR ")",
          first, count, (uintptr_t)textures);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        bool isCallValid =
            (context->skipValidation() || ValidateBindTextures(context, first, count, textures));
        if (isCallValid)
        {
            context->bindTextures(first, count, textures);
        }
        ANGLE_CAPTURE(BindTextures, isCallValid, context, first, count, textures);
    }
}

void GL_APIENTRY BindVertexBuffers(GLuint first,
                                   GLsizei count,
                                   const GLuint *buffers,
                                   const GLintptr *offsets,
                                   const GLsizei *strides)
{
    EVENT("(GLuint first = %u, GLsizei count = %d, const GLuint *buffers = 0x%016" PRIxPTR
          ", const GLintptr *offsets = 0x%016" PRIxPTR ", const GLsizei *strides = 0x%016" PRIxPTR
          ")",
          first, count, (uintptr_t)buffers, (uintptr_t)offsets, (uintptr_t)strides);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        bool isCallValid =
            (context->skipValidation() ||
             ValidateBindVertexBuffers(context, first, count, buffers, offsets, strides));
        if (isCallValid)
        {
            context->bindVertexBuffers(first, count, buffers, offsets, strides);
        }
        ANGLE_CAPTURE(BindVertexBuffers, isCallValid, context, first, count, buffers, offsets,
                      strides);
    }
}

void GL_APIENTRY BufferStorage(GLenum target, GLsizeiptr size, const void *data, GLbitfield flags)
{
    EVENT("(GLenum target = 0x%X, GLsizeiptr size = %llu, const void *data = 0x%016" PRIxPTR
          ", GLbitfield flags = 0x%X)",
          target, static_cast<unsigned long long>(size), (uintptr_t)data, flags);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        bool isCallValid = (context->skipValidation() ||
                            ValidateBufferStorage(context, target, size, data, flags));
        if (isCallValid)
        {
            context->bufferStorage(target, size, data, flags);
        }
        ANGLE_CAPTURE(BufferStorage, isCallValid, context, target, size, data, flags);
    }
}

void GL_APIENTRY
ClearTexImage(GLuint texture, GLint level, GLenum format, GLenum type, const void *data)
{
    EVENT(
        "(GLuint texture = %u, GLint level = %d, GLenum format = 0x%X, GLenum type = 0x%X, const "
        "void *data = 0x%016" PRIxPTR ")",
        texture, level, format, type, (uintptr_t)data);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        bool isCallValid = (context->skipValidation() ||
                            ValidateClearTexImage(context, texture, level, format, type, data));
        if (isCallValid)
        {
            context->clearTexImage(texture, level, format, type, data);
        }
        ANGLE_CAPTURE(ClearTexImage, isCallValid, context, texture, level, format, type, data);
    }
}

void GL_APIENTRY ClearTexSubImage(GLuint texture,
                                  GLint level,
                                  GLint xoffset,
                                  GLint yoffset,
                                  GLint zoffset,
                                  GLsizei width,
                                  GLsizei height,
                                  GLsizei depth,
                                  GLenum format,
                                  GLenum type,
                                  const void *data)
{
    EVENT(
        "(GLuint texture = %u, GLint level = %d, GLint xoffset = %d, GLint yoffset = %d, GLint "
        "zoffset = %d, GLsizei width = %d, GLsizei height = %d, GLsizei depth = %d, GLenum format "
        "= 0x%X, GLenum type = 0x%X, const void *data = 0x%016" PRIxPTR ")",
        texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type,
        (uintptr_t)data);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        bool isCallValid =
            (context->skipValidation() ||
             ValidateClearTexSubImage(context, texture, level, xoffset, yoffset, zoffset, width,
                                      height, depth, format, type, data));
        if (isCallValid)
        {
            context->clearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height,
                                      depth, format, type, data);
        }
        ANGLE_CAPTURE(ClearTexSubImage, isCallValid, context, texture, level, xoffset, yoffset,
                      zoffset, width, height, depth, format, type, data);
    }
}
}  // namespace gl
